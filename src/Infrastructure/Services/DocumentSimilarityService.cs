//Class generated by DeepSeek
using Application.Interfaces;
using MathNet.Numerics.LinearAlgebra;
using Microsoft.ML;
using Microsoft.ML.Transforms.Text;

namespace Infrastructure.Services;
public class DocumentSimilarityService : IDocumentSimilarityService
{
    private readonly MLContext _mlContext;
    private readonly IEstimator<ITransformer> _textPipeline;

    public DocumentSimilarityService()
    {
        _mlContext = new MLContext();

        // Define the embedding pipeline using IEstimator<ITransformer>
        _textPipeline = _mlContext.Transforms.Text
            .NormalizeText("NormalizedText", "Text")
            .Append(_mlContext.Transforms.Text.TokenizeIntoWords("Tokens", "NormalizedText"))
            .Append(_mlContext.Transforms.Text.ApplyWordEmbedding(
                outputColumnName: "Features",
                inputColumnName: "Tokens",
                modelKind: WordEmbeddingEstimator.PretrainedModelKind.SentimentSpecificWordEmbedding));
    }

    public bool[,] CalculateSimilarity(IList<string> stringList1, IList<string> stringList2)
    {
        float[][] embeddingsA = GetEmbeddings(stringList1);
        float[][] embeddingsB = GetEmbeddings(stringList2);

        float[,] similarityMatrix = ComputeSimilarityMatrix(embeddingsA, embeddingsB);

        bool[,] returnArray = new bool[stringList1.Count, stringList2.Count];

        for (int i = 0; i < stringList1.Count; i++)
        {
            for (int j = 0; j < stringList2.Count; j++)
            {
                if (similarityMatrix[i, j] >= 0.8f)
                {
                    returnArray[i, j] = true;
                }
            }
        }

        return returnArray;
    }

    // Precompute embeddings for all offers
    private float[][] GetEmbeddings(IList<string> offers)
    {
        var data = _mlContext.Data.LoadFromEnumerable(offers.Select(o => new TextData { Text = o }));
        var transformer = _textPipeline.Fit(data);
        var transformedData = transformer.Transform(data);

        return _mlContext.Data.CreateEnumerable<EmbeddingOutput>(transformedData, reuseRowObject: false)
            .Select(e => e.Features)
            .ToArray();
    }

    // Compute all pairwise similarities
    private float[,] ComputeSimilarityMatrix(float[][] embeddingsList1, float[][] embeddingsList2)
    {
        int count1 = embeddingsList1.Length;
        int count2 = embeddingsList2.Length;
        var similarityMatrix = Matrix<float>.Build.Dense(count1, count2);

        Parallel.For(0, count1, i =>
        {
            for (int j = 0; j < count2; j++)
            {
                similarityMatrix[i, j] = ComputeCosineSimilarity(embeddingsList1[i], embeddingsList2[j]);
            }
        });

        return similarityMatrix.ToArray();
    }

    private float ComputeCosineSimilarity(float[] vector1, float[] vector2)
    {
        float dotProduct = 0.0f, magnitude1 = 0.0f, magnitude2 = 0.0f;
        for (int i = 0; i < vector1.Length; i++)
        {
            dotProduct += vector1[i] * vector2[i];
            magnitude1 += vector1[i] * vector1[i];
            magnitude2 += vector2[i] * vector2[i];
        }
        return dotProduct / (MathF.Sqrt(magnitude1) * MathF.Sqrt(magnitude2));
    }

    private class TextData { public string Text { get; set; } }
    private class EmbeddingOutput { public float[] Features { get; set; } }
}
